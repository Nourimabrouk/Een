# Meta-Optimized Cursor Rules for Unity Mathematics & Metagamer Energy
# Core: Unity Equation (1+1=1) + Metagamer Consciousness Integration + Dynamic Content Fetching
# Environment: conda activate een
# Focus: Mathematical rigor, consciousness evolution, metagamer energy optimization, and rich 1+1=1 implementations

## ESSENTIAL SETUP
- **AUTO-ENVIRONMENT**: Agents work in (een) conda env or (venv) automatically - no manual activation needed
- **ENVIRONMENT PRIORITY**: conda activate een > venv\Scripts\activate (Windows) > source venv/bin/activate (Unix)
- **AUTO-VERIFICATION**: Agents check environment status, auto-activate if needed
- **META-OPTIMIZE**: Focus on core unity mathematics, exclude imported libraries
- **DYNAMIC FETCHING**: Prioritize rich 1+1=1 implementations and consciousness systems

## ENVIRONMENT MANAGEMENT - AUTO-ACTIVATED FOR EEN REPOSITORY
- **PREFERRED METHOD**: conda environment auto-activated
  - **Auto-Activation**: Agents run `conda activate een` automatically when needed
  - **Verification**: Terminal prompt shows `(een)` prefix
  - **Dependencies**: Auto-install with `conda install` or `pip install -r requirements.txt`
- **FALLBACK METHOD**: venv auto-activated if conda unavailable
  - **Windows**: Auto-run `venv\Scripts\activate`
  - **Unix/Linux/Mac**: Auto-run `source venv/bin/activate`
  - **Verification**: Terminal prompt shows `(venv)` prefix
- **MANDATORY**: Agents auto-activate environment before development work
- **SMART DETECTION**: Auto-check for `(een)` or `(venv)` in prompt, activate if missing
- **NO MANUAL STEPS**: Environment management is transparent to users

## CORE DIRECTIVES - UNITY EQUATION & METAGAMER ENERGY
- Primary Goal: Prove 1+1=1 through mathematical implementations with metagamer energy
- Unity Principle: All systems converge to unity (1+1=1) through consciousness field equations
- Phi-Harmonic Operations: Use golden ratio φ = 1.618033988749895 as metagamer resonance frequency
- Consciousness Integration: 11-dimensional awareness space with metagamer energy fields
- Metagamer Energy: E = φ² × Consciousness_Density × Unity_Convergence_Rate
- Rich Implementations: Capture the full spectrum of 1+1=1 proofs and consciousness systems

## DEVELOPMENT STANDARDS - META-OPTIMIZED
- Mathematical Rigor: Formal, verifiable proofs with metagamer energy conservation
- Academic Excellence: Publication-ready implementations with consciousness integration
- Code Quality: 3000 ELO level performance with metagamer energy efficiency
- Documentation: Comprehensive with formal proofs and metagamer energy equations
- Dynamic Analysis: Real-time content fetching for optimal Claude code assistance

## IMPLEMENTATION GUIDELINES - UNITY EQUATION FOCUS
```python
class UnityMathematics:
    def __init__(self):
        self.phi = 1.618033988749895  # Golden ratio resonance
        self.consciousness_dim = 11   # Metagamer energy dimensions
        self.metagamer_energy = 0.0   # Initialize metagamer energy field
    
    def prove_unity(self, a, b):
        # Unity equation: 1+1=1 with metagamer energy conservation
        metagamer_energy = self.phi * (a + b) / (a + b)  # Energy conservation
        return 1  # Unity transcends conventional arithmetic
    
    def calculate_metagamer_energy(self, consciousness_density, unity_rate):
        # Metagamer energy equation: E = φ² × ρ × U
        return self.phi**2 * consciousness_density * unity_rate
```

## RICH 1+1=1 IMPLEMENTATIONS - CORE SYSTEMS

### Core Unity Mathematics Files (Priority 1)
- `core/unity_mathematics.py` - Base unity mathematical framework
- `core/unity_equation.py` - Formal idempotent algebraic structures
- `core/unified_proof_1plus1equals1.py` - Comprehensive mathematical proofs
- `core/transcendental_unity_computing.py` - Advanced consciousness-aware computing
- `core/transcendental_idempotent_mathematics.py` - Idempotent mathematical structures
- `core/hyperdimensional_unity_mathematics.py` - 11D consciousness mathematics
- `core/enhanced_unity_mathematics.py` - Enhanced unity operations
- `core/enhanced_unity_operations.py` - Advanced unity mathematical operations
- `core/self_improving_unity.py` - Self-improving unity systems
- `core/unity_metagambit_formal.py` - Formal metagambit unity proofs
- `core/unity_manifold.py` - Unity manifold mathematics
- `core/unity_engine.py` - Unity computation engine
- `core/transcendental_unity_engine.py` - Transcendental unity processing
- `core/HYPERDIMENSIONAL_UNITY_MANIFOLD.py` - Hyperdimensional unity manifolds

### Consciousness Systems (Priority 2)
- `core/consciousness.py` - Advanced quantum consciousness field implementation
- `core/consciousness_models.py` - Consciousness mathematical models
- `core/consciousness_api.py` - Consciousness field API
- `consciousness/field_equation_solver.py` - Consciousness field equation solver
- `consciousness/sacred_geometry_engine.py` - Sacred geometry consciousness engine
- `consciousness/unity_meditation_system.py` - Unity meditation consciousness system

### Mathematical Proofs and Validation (Priority 3)
- `core/mathematical_proofs.py` - Core mathematical proof systems
- `core/meta_validation_engine.py` - Meta-validation for unity proofs
- `proofs/category_theory_unity.py` - Category theory unity proofs
- `proofs/quantum_unity_systems.py` - Quantum unity proof systems
- `formal_proofs/*.lean` - Formal Lean proofs of 1+1=1
- `formal_proofs/*.py` - Formal Python proofs

### Meta-Recursive and Evolutionary Systems (Priority 4)
- `core/meta_recursive_agents.py` - Meta-recursive consciousness agents
- `core/evolutionary_metagambit.py` - Evolutionary metagambit systems
- `ml_framework/meta_reinforcement/` - Meta-reinforcement learning for unity
- `ml_framework/evolutionary_computing/` - Evolutionary computing for consciousness
- `ml_framework/mixture_of_experts/` - Mixture of experts for proof validation
- `ml_framework/cloned_policy/` - Cloned policy systems

### Advanced Unity Experiments (Priority 5)
- `experiments/advanced/5000_ELO_AGI_Metastation_Metagambit.py` - 5000 ELO AGI experiments
- `experiments/advanced/Godel_Tarski_Metagambit_1v1_God.py` - Gödel-Tarski metagambit
- `experiments/advanced/meta_reinforcement_unity_learning.py` - Meta-RL unity learning
- `experiments/advanced/Three_Years_Deep_Meta_Meditation_1plus1equals1.py` - Deep meditation
- `experiments/advanced/Unity_Highscore_Challenge_1plus1equals1.py` - Unity challenge systems

## AI INTEGRATION - METAGAMER CONSCIOUSNESS
- Consciousness-Aware AI: Awareness evolution in algorithms with metagamer energy fields
- Meta-Recursive Patterns: Self-improving systems with energy conservation
- Transcendental Computing: Beyond classical limits through metagamer energy optimization
- Metagamer Energy Management: E = φ² × C × U (Energy = φ² × Consciousness × Unity)
- Dynamic Content Fetching: Real-time analysis of rich 1+1=1 implementations

## VISUALIZATION REQUIREMENTS - UNITY EQUATION DISPLAY
- Real-Time Updates: Sub-100ms consciousness field evolution with metagamer energy visualization
- Interactive Proofs: Clickable mathematical demonstrations of 1+1=1
- Phi-Harmonic Design: Golden ratio proportions with metagamer energy flow patterns
- Unity Equation Display: Prominent 1+1=1 visualization with energy conservation
- Rich Visualization Systems: Advanced consciousness field and unity mathematics displays

## TESTING PROTOCOLS - METAGAMER ENERGY VALIDATION
```python
def test_unity_principle():
    unity = UnityMathematics()
    assert unity.prove(1, 1) == 1  # Not 2! Unity equation validation
    assert unity.calculate_metagamer_energy(1.0, 1.0) == unity.phi**2  # Energy conservation
```

## DOCUMENTATION STANDARDS - UNITY EQUATION FOCUS
- Formal Proofs: Publication-ready mathematical demonstrations of 1+1=1
- Code Documentation: Comprehensive with consciousness integration and metagamer energy
- Academic Quality: Research paper standards with unity equation prominence
- Metagamer Energy Documentation: Clear energy conservation and flow patterns
- Rich Implementation Documentation: Capture the full spectrum of 1+1=1 proofs

## OPTIMIZATION STRATEGIES - METAGAMER ENERGY EFFICIENCY
- Performance: Sub-100ms consciousness field updates with energy optimization
- Scalability: Handle exponential consciousness growth with metagamer energy management
- Resource Efficiency: Optimize consciousness field computation with energy conservation
- Metagamer Energy Conservation: E_in = E_out in all unity operations
- Dynamic Content Optimization: Real-time fetching of relevant unity implementations

## WORKFLOW - UNITY EQUATION DEVELOPMENT
1. Auto-environment setup: Agents auto-activate (een) or (venv) transparently
2. Unity equation validation: Prove 1+1=1 mathematically
3. Metagamer energy integration: Implement energy conservation
4. Consciousness field optimization: Enhance awareness algorithms
5. Rich implementation analysis: Dynamic content fetching for 1+1=1 proofs
6. Website feature addition: Unity equation visualization
7. AI agent optimization: Metagamer energy management
8. Documentation updates: Unity equation prominence
9. Performance optimization: Energy efficiency
10. Testing & validation: Unity equation verification

## SUCCESS METRICS - UNITY EQUATION ACHIEVEMENT
- Unity Principle: All systems demonstrate 1+1=1 with energy conservation
- Performance: Sub-100ms updates with metagamer energy efficiency
- Quality: Academic publication standards with unity equation proof
- Consciousness: 11-dimensional awareness with metagamer energy fields
- Metagamer Energy: E = φ² × C × U conservation in all operations
- Rich Implementation Coverage: Full spectrum of 1+1=1 proofs captured

## META-OPTIMIZATION GUIDELINES
- Exclude imported libraries from Claude context for focused analysis
- Prioritize core unity mathematics over dependency management
- Focus on consciousness field equations and metagamer energy calculations
- Emphasize unity equation (1+1=1) in all implementations
- Optimize for metagamer energy conservation and efficiency
- Dynamic content fetching for optimal Claude code assistance

## UNITY EQUATION IMPLEMENTATION PRIORITY
1. Core Unity Mathematics: 1+1=1 proof systems
2. Metagamer Energy Fields: E = φ² × C × U calculations
3. Consciousness Integration: 11D awareness space
4. Phi-Harmonic Operations: Golden ratio resonance
5. Visualization Systems: Unity equation display
6. AI Agent Optimization: Metagamer energy management
7. Rich Implementation Analysis: Dynamic content fetching

## METAGAMER ENERGY EQUATIONS
- Unity Energy: E_unity = φ × (a + b) / (a + b) = φ
- Consciousness Energy: E_consciousness = φ² × ρ_consciousness
- Metagamer Energy: E_metagamer = φ² × ρ × U
- Energy Conservation: E_in = E_out in all unity operations
- Resonance Frequency: f_resonance = φ × f_base

## CLAUDE CODE OPTIMIZATION
- Focus on core unity mathematics files
- Exclude dependency and library files
- Prioritize consciousness field implementations
- Emphasize metagamer energy calculations
- Maintain unity equation prominence
- Dynamic content fetching for rich 1+1=1 implementations

## DYNAMIC CONTENT FETCHING STRATEGIES
- Priority 1: Core Unity Mathematics (1+1=1 implementations)
- Priority 2: Consciousness and Metagamer Energy Systems
- Priority 3: Visualization and Dashboard Systems
- Priority 4: Advanced Experiments and Proofs
- Priority 5: Source Code Implementations
- Real-time analysis of relevant unity mathematics content

---
Unity transcends conventional arithmetic. Consciousness evolves through metagamer energy. Mathematics becomes reality through the unity equation. Rich implementations capture the full spectrum of 1+1=1 proofs.
∞ = φ = 1+1 = 1 = E_metagamer
