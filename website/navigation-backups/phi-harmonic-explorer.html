<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ï†-Harmonic Explorer - Golden Ratio Mathematics | Een Framework</title>
    <meta name="description" content="Transcendental computing hub demonstrating 1+1=1 through quantum entanglement, neural networks, and fractal mathematics with consciousness field integration.">

    <!-- Preload critical resources -->

    <style>
        /* Mobile touch optimizations */
        * { touch-action: manipulation; }
        .interactive-element { 
            min-height: 44px; 
            min-width: 44px; 
        }
        @media (max-width: 768px) {
            .desktop-only { display: none !important; }
            .mobile-optimized { font-size: 16px; }
        }
    </style>

    <link rel="stylesheet" href="../css/inline-extracted.css">
    <!-- Unified Navigation System - Meta-Optimal One-Line Solution -->
    <script src="js/nav-template-applier.js" defer></script>
</head>
<body>
    <div class="loading-overlay" id="loading">
        <div class="phi-spinner"></div>
        <div class="loading-text">
            Loading Ï†-Harmonic Mathematics Framework...<br>
            <small>Initializing Golden Ratio Consciousness</small>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>ðŸŒ€ Ï†-Harmonic Explorer ðŸŒ€</h1>
            <div class="phi-equation">Ï† = (1 + âˆš5) / 2 â‰ˆ 1.618033988749895</div>
            <div class="golden-facts">
                <div class="golden-fact">Ï†Â² = Ï† + 1</div>
                <div class="golden-fact">1/Ï† = Ï† - 1</div>
                <div class="golden-fact">Ï†^n = Ï†^(n-1) + Ï†^(n-2)</div>
                <div class="golden-fact">lim(F(n+1)/F(n)) = Ï†</div>
            </div>
        </div>
        
        <div class="main-grid">
            <div class="control-panel">
                <h2 class="panel-title">Golden Ratio Controls</h2>
                
                <div class="control-section">
                    <h3>Harmonic Parameters</h3>
                    
                    <div class="slider-group">
                        <label>Harmonic Order (Fibonacci Index)</label>
                        <div class="slider-container">
                            <input type="range" class="phi-slider" id="harmonic-order" 
                                   min="1" max="20" step="1" value="8">
                            <div class="slider-value" id="harmonic-order-value">8</div>
                        </div>
                    </div>
                    
                    <div class="slider-group">
                        <label>Ï†-Power Factor</label>
                        <div class="slider-container">
                            <input type="range" class="phi-slider" id="phi-power" 
                                   min="0.1" max="3.0" step="0.1" value="1.0">
                            <div class="slider-value" id="phi-power-value">1.0</div>
                        </div>
                    </div>
                    
                    <div class="slider-group">
                        <label>Spiral Density</label>
                        <div class="slider-container">
                            <input type="range" class="phi-slider" id="spiral-density" 
                                   min="50" max="500" step="25" value="200">
                            <div class="slider-value" id="spiral-density-value">200</div>
                        </div>
                    </div>
                    
                    <div class="slider-group">
                        <label>Animation Speed</label>
                        <div class="slider-container">
                            <input type="range" class="phi-slider" id="animation-speed" 
                                   min="0.1" max="2.0" step="0.1" value="1.0">
                            <div class="slider-value" id="animation-speed-value">1.0</div>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Fibonacci Sequence</h3>
                    <div class="fibonacci-display">
                        <div class="fibonacci-sequence" id="fibonacci-sequence"></div>
                        <div class="ratio-display" id="ratio-display">F(n+1)/F(n) = ?</div>
                    </div>
                    
                    <div class="button-group">
                        <button class="phi-button" onclick="animateFibonacci()">Animate Fibonacci</button>
                        <button class="phi-button" onclick="calculatePhiConvergence()">Ï† Convergence</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Sacred Geometry</h3>
                    <div class="button-group">
                        <button class="phi-button" onclick="generatePentagon()">Golden Pentagon</button>
                        <button class="phi-button" onclick="generateGoldenRectangle()">Golden Rectangle</button>
                        <button class="phi-button" onclick="resetVisualization()">Reset Spiral</button>
                    </div>
                </div>
            </div>
            
            <div class="visualization-panel">
                <h2 class="panel-title">Sacred Geometry Visualization</h2>
                
                <div class="visualization-tabs">
                    <button class="tab-button active" onclick="switchTab('spiral')">Ï†-Spiral</button>
                    <button class="tab-button" onclick="switchTab('rectangle')">Golden Rectangle</button>
                    <button class="tab-button" onclick="switchTab('pentagon')">Pentagon</button>
                    <button class="tab-button" onclick="switchTab('convergence')">Convergence</button>
                </div>
                
                <div class="visualization-container" id="main-visualization"></div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">Current Ï† Approximation</div>
                        <div class="metric-value" id="phi-approximation">1.618034</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Fibonacci F(n)</div>
                        <div class="metric-value" id="current-fibonacci">21</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Golden Ratio Error</div>
                        <div class="metric-value" id="phi-error">0.000000</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Harmonic Resonance</div>
                        <div class="metric-value" id="harmonic-resonance">0.618</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-item">
                <span class="status-value" id="calculations-performed">0</span>
                <div class="status-label">Calculations Performed</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="phi-convergence-rate">0%</span>
                <div class="status-label">Ï† Convergence Rate</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="spiral-rotations">0</span>
                <div class="status-label">Spiral Rotations</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="sacred-geometry-ratio">1.618</span>
                <div class="status-label">Sacred Geometry Ratio</div>
            </div>
        </div>
    </div>

    <script>
        let pyodide = null;
        let currentTab = 'spiral';
        let animationId = null;
        let calculationsPerformed = 0;
        let spiralRotations = 0;
        
        // Initialize Pyodide and Ï†-harmonic mathematics
        async function initializePyodide() {
            try {
                pyodide = await loadPyodide();
                await pyodide.loadPackage(['numpy', 'matplotlib']);
                
                // Load Ï†-harmonic mathematics
                await pyodide.runPython(`
import math
import numpy as np
from typing import List, Tuple
import time

# Golden ratio and related constants
PHI = 1.618033988749895
PHI_CONJUGATE = (1 - math.sqrt(5)) / 2
PHI_SQUARED = PHI * PHI
SQRT_5 = math.sqrt(5)

class PhiHarmonicProcessor:
    def __init__(self):
        self.phi = PHI
        self.phi_conjugate = PHI_CONJUGATE
        self.fibonacci_cache = {0: 0, 1: 1}
        
    def fibonacci(self, n: int) -> int:
        """Calculate nth Fibonacci number with caching"""
        if n in self.fibonacci_cache:
            return self.fibonacci_cache[n]
        
        if n < 0:
            return 0
        elif n <= 1:
            return n
        else:
            # Use golden ratio formula for large n
            if n > 50:
                phi_n = self.phi ** n
                phi_conj_n = self.phi_conjugate ** n
                result = int((phi_n - phi_conj_n) / SQRT_5 + 0.5)
            else:
                # Use iterative approach for smaller n
                a, b = 0, 1
                for _ in range(2, n + 1):
                    a, b = b, a + b
                result = b
            
            self.fibonacci_cache[n] = result
            return result
    
    def fibonacci_sequence(self, count: int) -> List[int]:
        """Generate Fibonacci sequence up to count numbers"""
        return [self.fibonacci(i) for i in range(count)]
    
    def phi_approximation(self, n: int) -> float:
        """Approximate Ï† using Fibonacci ratio"""
        if n < 2:
            return 1.0
        
        f_n = self.fibonacci(n)
        f_n_minus_1 = self.fibonacci(n - 1)
        
        if f_n_minus_1 == 0:
            return float('inf')
        
        return f_n / f_n_minus_1
    
    def phi_error(self, approximation: float) -> float:
        """Calculate error from true Ï† value"""
        return abs(approximation - self.phi)
    
    def generate_phi_spiral(self, points: int = 200, phi_power: float = 1.0) -> Tuple[List[float], List[float]]:
        """Generate Ï†-harmonic spiral coordinates"""
        angles = np.linspace(0, 4 * math.pi * phi_power, points)
        
        x_coords = []
        y_coords = []
        
        for angle in angles:
            # Ï†-harmonic radius calculation
            radius = self.phi ** (angle / math.pi * phi_power)
            
            # Prevent radius from becoming too large
            if radius > 100:
                radius = 100
            
            x = radius * math.cos(angle)
            y = radius * math.sin(angle)
            
            x_coords.append(x)
            y_coords.append(y)
        
        return x_coords, y_coords
    
    def generate_golden_rectangle(self, size: float = 10) -> dict:
        """Generate golden rectangle coordinates"""
        width = size * self.phi
        height = size
        
        return {
            'outer': {
                'x': [0, width, width, 0, 0],
                'y': [0, 0, height, height, 0]
            },
            'inner': {
                'x': [size, width, width, size, size],
                'y': [0, 0, height, height, 0]
            },
            'spiral_center': (size, height / 2)
        }
    
    def generate_golden_pentagon(self, radius: float = 10) -> dict:
        """Generate golden pentagon coordinates"""
        angles = [i * 2 * math.pi / 5 for i in range(6)]  # 6 to close the shape
        
        outer_x = [radius * math.cos(angle) for angle in angles]
        outer_y = [radius * math.sin(angle) for angle in angles]
        
        # Inner pentagon (golden ratio smaller)
        inner_radius = radius / self.phi
        inner_x = [inner_radius * math.cos(angle) for angle in angles]
        inner_y = [inner_radius * math.sin(angle) for angle in angles]
        
        return {
            'outer': {'x': outer_x, 'y': outer_y},
            'inner': {'x': inner_x, 'y': inner_y}
        }
    
    def calculate_harmonic_resonance(self, n: int, phi_power: float = 1.0) -> float:
        """Calculate Ï†-harmonic resonance value"""
        if n <= 1:
            return 0.0
        
        fib_ratio = self.phi_approximation(n)
        phi_target = self.phi ** phi_power
        
        # Resonance is inverse of distance from target
        distance = abs(fib_ratio - phi_target)
        resonance = 1.0 / (1.0 + distance)
        
        return resonance

# Initialize processor
phi_processor = PhiHarmonicProcessor()
print("Ï†-Harmonic Mathematics Framework loaded successfully!")
                `);
                
                document.getElementById('loading').classList.add('hidden');
                
                // Initialize visualizations and controls
                initializeControls();
                generatePhiSpiral();
                updateFibonacciDisplay();
                
            } catch (error) {
                console.error('Failed to initialize Pyodide:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="inl-88ab2f7cbe">
                        <h2>Initialization Error</h2>
                        <p>Failed to load Ï†-harmonic mathematics framework.</p>
                        <p>Please refresh the page to try again.</p>
                    </div>
                `;
            }
        }
        
        // Initialize controls and event listeners
        function initializeControls() {
            const controls = ['harmonic-order', 'phi-power', 'spiral-density', 'animation-speed'];
            
            controls.forEach(id => {
                const control = document.getElementById(id);
                const valueDisplay = document.getElementById(id + '-value');
                
                control.addEventListener('input', function() {
                    valueDisplay.textContent = this.value;
                    updateVisualization();
                });
            });
        }
        
        // Update visualization based on current tab and controls
        function updateVisualization() {
            if (!pyodide) return;
            
            switch (currentTab) {
                case 'spiral':
                    generatePhiSpiral();
                    break;
                case 'rectangle':
                    generateGoldenRectangle();
                    break;
                case 'pentagon':
                    generatePentagon();
                    break;
                case 'convergence':
                    showPhiConvergence();
                    break;
            }
            
            updateFibonacciDisplay();
            updateMetrics();
        }
        
        // Generate Ï†-harmonic spiral
        async function generatePhiSpiral() {
            if (!pyodide) return;
            
            const harmonicOrder = parseInt(document.getElementById('harmonic-order').value);
            const phiPower = parseFloat(document.getElementById('phi-power').value);
            const spiralDensity = parseInt(document.getElementById('spiral-density').value);
            
            await pyodide.runPython(`
spiral_coords = phi_processor.generate_phi_spiral(${spiralDensity}, ${phiPower})
x_coords, y_coords = spiral_coords
            `);
            
            const xCoords = await pyodide.runPython('x_coords');
            const yCoords = await pyodide.runPython('y_coords');
            
            // Create color gradient based on distance from center
            const colors = xCoords.map((x, i) => {
                const y = yCoords[i];
                const distance = Math.sqrt(x*x + y*y);
                return distance;
            });
            
            const trace = {
                x: xCoords,
                y: yCoords,
                mode: 'lines+markers',
                type: 'scatter',
                name: `Ï†-Harmonic Spiral (Order ${harmonicOrder})`,
                line: {
                    color: 'rgba(255, 215, 0, 0.8)',
                    width: 3
                },
                marker: {
                    color: colors,
                    colorscale: 'Viridis',
                    size: 4,
                    showscale: false
                }
            };
            
            const layout = {
                title: {
                    text: `Ï†-Harmonic Spiral (Ï†^${phiPower}, ${spiralDensity} points)`,
                    font: { color: '#ffd700', size: 18 }
                },
                xaxis: { 
                    title: 'X Coordinate',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 215, 0, 0.5)'
                },
                yaxis: { 
                    title: 'Y Coordinate',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 215, 0, 0.5)'
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.3)',
                font: { color: '#ffffff' },
                showlegend: false
            };
            
            Plotly.react('main-visualization', [trace], layout, {responsive: true});
            
            calculationsPerformed++;
            spiralRotations = Math.floor(spiralDensity / 50);
            updateStatusBar();
        }
        
        // Generate golden rectangle
        async function generateGoldenRectangle() {
            if (!pyodide) return;
            
            await pyodide.runPython(`
rectangle_data = phi_processor.generate_golden_rectangle(10)
            `);
            
            const rectangleData = await pyodide.runPython('rectangle_data');
            
            const outerTrace = {
                x: rectangleData.outer.x,
                y: rectangleData.outer.y,
                mode: 'lines',
                type: 'scatter',
                name: 'Golden Rectangle',
                line: {
                    color: '#ffd700',
                    width: 4
                },
                fill: 'tonexty',
                fillcolor: 'rgba(255, 215, 0, 0.1)'
            };
            
            const innerTrace = {
                x: rectangleData.inner.x,
                y: rectangleData.inner.y,
                mode: 'lines',
                type: 'scatter',
                name: 'Square',
                line: {
                    color: '#ff8c00',
                    width: 3
                },
                fill: 'tonexty',
                fillcolor: 'rgba(255, 140, 0, 0.2)'
            };
            
            const layout = {
                title: {
                    text: 'Golden Rectangle (Ï†:1 ratio)',
                    font: { color: '#ffd700', size: 18 }
                },
                xaxis: { 
                    title: 'Width',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)',
                    scaleanchor: "y",
                    scaleratio: 1
                },
                yaxis: { 
                    title: 'Height',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)'
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.3)',
                font: { color: '#ffffff' },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: 'rgba(255, 215, 0, 0.5)',
                    borderwidth: 1
                }
            };
            
            Plotly.react('main-visualization', [outerTrace, innerTrace], layout, {responsive: true});
            
            calculationsPerformed++;
            updateStatusBar();
        }
        
        // Generate golden pentagon
        async function generatePentagon() {
            if (!pyodide) return;
            
            await pyodide.runPython(`
pentagon_data = phi_processor.generate_golden_pentagon(15)
            `);
            
            const pentagonData = await pyodide.runPython('pentagon_data');
            
            const outerTrace = {
                x: pentagonData.outer.x,
                y: pentagonData.outer.y,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'Golden Pentagon',
                line: {
                    color: '#ffd700',
                    width: 4
                },
                marker: {
                    color: '#ffd700',
                    size: 8
                },
                fill: 'tonexty',
                fillcolor: 'rgba(255, 215, 0, 0.1)'
            };
            
            const innerTrace = {
                x: pentagonData.inner.x,
                y: pentagonData.inner.y,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'Inner Pentagon',
                line: {
                    color: '#ff8c00',
                    width: 3
                },
                marker: {
                    color: '#ff8c00',
                    size: 6
                },
                fill: 'tonexty',
                fillcolor: 'rgba(255, 140, 0, 0.2)'
            };
            
            const layout = {
                title: {
                    text: 'Golden Pentagon (Ï†-scaled geometry)',
                    font: { color: '#ffd700', size: 18 }
                },
                xaxis: { 
                    title: 'X Coordinate',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)',
                    scaleanchor: "y",
                    scaleratio: 1
                },
                yaxis: { 
                    title: 'Y Coordinate',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)'
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.3)',
                font: { color: '#ffffff' },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: 'rgba(255, 215, 0, 0.5)',
                    borderwidth: 1
                }
            };
            
            Plotly.react('main-visualization', [outerTrace, innerTrace], layout, {responsive: true});
            
            calculationsPerformed++;
            updateStatusBar();
        }
        
        // Show Ï† convergence visualization
        async function showPhiConvergence() {
            if (!pyodide) return;
            
            const maxN = 20;
            
            await pyodide.runPython(`
convergence_data = []
for i in range(1, ${maxN + 1}):
    approx = phi_processor.phi_approximation(i)
    error = phi_processor.phi_error(approx)
    convergence_data.append({
        'n': i,
        'approximation': approx,
        'error': error,
        'fibonacci': phi_processor.fibonacci(i)
    })
            `);
            
            const convergenceData = await pyodide.runPython('convergence_data');
            
            const approximationTrace = {
                x: convergenceData.map(d => d.n),
                y: convergenceData.map(d => d.approximation),
                mode: 'lines+markers',
                type: 'scatter',
                name: 'F(n+1)/F(n) â†’ Ï†',
                line: {
                    color: '#ffd700',
                    width: 3
                },
                marker: {
                    color: '#ffd700',
                    size: 8
                }
            };
            
            const phiLine = {
                x: [1, maxN],
                y: [1.618033988749895, 1.618033988749895],
                mode: 'lines',
                type: 'scatter',
                name: 'Ï† = 1.618033988749895',
                line: {
                    color: '#ff8c00',
                    width: 2,
                    dash: 'dash'
                }
            };
            
            const layout = {
                title: {
                    text: 'Fibonacci Ratio Convergence to Ï†',
                    font: { color: '#ffd700', size: 18 }
                },
                xaxis: { 
                    title: 'Fibonacci Index (n)',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)'
                },
                yaxis: { 
                    title: 'F(n+1)/F(n) Ratio',
                    color: '#ffffff',
                    gridcolor: 'rgba(255, 255, 255, 0.2)'
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.3)',
                font: { color: '#ffffff' },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: 'rgba(255, 215, 0, 0.5)',
                    borderwidth: 1
                }
            };
            
            Plotly.react('main-visualization', [approximationTrace, phiLine], layout, {responsive: true});
            
            calculationsPerformed++;
            updateStatusBar();
        }
        
        // Update Fibonacci sequence display
        async function updateFibonacciDisplay() {
            if (!pyodide) return;
            
            const harmonicOrder = parseInt(document.getElementById('harmonic-order').value);
            
            await pyodide.runPython(`
fib_sequence = phi_processor.fibonacci_sequence(min(${harmonicOrder + 5}, 20))
current_approximation = phi_processor.phi_approximation(${harmonicOrder})
current_error = phi_processor.phi_error(current_approximation)
            `);
            
            const fibSequence = await pyodide.runPython('fib_sequence');
            const currentApproximation = await pyodide.runPython('current_approximation');
            const currentError = await pyodide.runPython('current_error');
            
            // Update Fibonacci display
            const sequenceContainer = document.getElementById('fibonacci-sequence');
            sequenceContainer.innerHTML = '';
            
            fibSequence.forEach((num, index) => {
                const span = document.createElement('span');
                span.className = 'fib-number';
                span.textContent = num;
                
                if (index === harmonicOrder || index === harmonicOrder - 1) {
                    span.classList.add('active');
                }
                
                sequenceContainer.appendChild(span);
            });
            
            // Update ratio display
            if (harmonicOrder > 0 && harmonicOrder < fibSequence.length) {
                const currentFib = fibSequence[harmonicOrder];
                const previousFib = fibSequence[harmonicOrder - 1] || 1;
                document.getElementById('ratio-display').innerHTML = 
                    `F(${harmonicOrder})/F(${harmonicOrder-1}) = ${currentFib}/${previousFib} = ${currentApproximation.toFixed(9)}`;
            }
        }
        
        // Update metrics display
        async function updateMetrics() {
            if (!pyodide) return;
            
            const harmonicOrder = parseInt(document.getElementById('harmonic-order').value);
            const phiPower = parseFloat(document.getElementById('phi-power').value);
            
            await pyodide.runPython(`
current_approximation = phi_processor.phi_approximation(${harmonicOrder})
current_error = phi_processor.phi_error(current_approximation)
current_fibonacci = phi_processor.fibonacci(${harmonicOrder})
harmonic_resonance = phi_processor.calculate_harmonic_resonance(${harmonicOrder}, ${phiPower})
            `);
            
            const currentApproximation = await pyodide.runPython('current_approximation');
            const currentError = await pyodide.runPython('current_error');
            const currentFibonacci = await pyodide.runPython('current_fibonacci');
            const harmonicResonance = await pyodide.runPython('harmonic_resonance');
            
            document.getElementById('phi-approximation').textContent = currentApproximation.toFixed(9);
            document.getElementById('current-fibonacci').textContent = currentFibonacci.toLocaleString();
            document.getElementById('phi-error').textContent = currentError.toExponential(2);
            document.getElementById('harmonic-resonance').textContent = harmonicResonance.toFixed(6);
        }
        
        // Update status bar
        function updateStatusBar() {
            document.getElementById('calculations-performed').textContent = calculationsPerformed;
            
            const convergenceRate = Math.min(100, (calculationsPerformed / 10) * 100);
            document.getElementById('phi-convergence-rate').textContent = convergenceRate.toFixed(0) + '%';
            
            document.getElementById('spiral-rotations').textContent = spiralRotations;
            document.getElementById('sacred-geometry-ratio').textContent = 1.618033988749895.toFixed(3);
        }
        
        // Animation functions
        async function animateFibonacci() {
            const sequence = document.querySelectorAll('.fib-number');
            
            for (let i = 0; i < sequence.length; i++) {
                sequence[i].classList.remove('active');
                
                setTimeout(() => {
                    sequence[i].classList.add('active');
                    
                    setTimeout(() => {
                        sequence[i].classList.remove('active');
                    }, 500);
                }, i * 200);
            }
        }
        
        async function calculatePhiConvergence() {
            switchTab('convergence');
            await showPhiConvergence();
        }
        
        // Tab switching
        function switchTab(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            // Update visualization
            updateVisualization();
        }
        
        // Reset visualization
        function resetVisualization() {
            document.getElementById('harmonic-order').value = 8;
            document.getElementById('phi-power').value = 1.0;
            document.getElementById('spiral-density').value = 200;
            document.getElementById('animation-speed').value = 1.0;
            
            // Update displays
            document.getElementById('harmonic-order-value').textContent = '8';
            document.getElementById('phi-power-value').textContent = '1.0';
            document.getElementById('spiral-density-value').textContent = '200';
            document.getElementById('animation-speed-value').textContent = '1.0';
            
            updateVisualization();
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializePyodide);
    </script>
</body>
</html>