<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Transcendental Hero Section -->
    <section class="transcendental-hero">
        <canvas class="hero-background" id="heroCanvas"></canvas>
        <div class="hero-content">
            <div class="unity-equation" id="unityEquation">1 + 1 = 1</div>
            <p class="hero-tagline">Transcendental Mathematics Through Consciousness Visualization</p>
            <div class="consciousness-mantra">Thou Art That ‚Ä¢ Tat Tvam Asi ‚Ä¢ ‡§§‡§§‡•ç ‡§§‡•ç‡§µ‡§Æ‡•ç ‡§Ö‡§∏‡§ø</div>
        </div>
    </section>

    <!-- Interactive Unity Proof Explorer -->
    <section class="unity-proof-explorer">
        <div class="container">
            <h2 class="section-title">üßÆ Interactive Unity Proof Explorer</h2>
            <p class="section-subtitle">Experience 1+1=1 through multiple mathematical paradigms</p>

            <div class="proof-grid">
                <div class="proof-item active" onclick="activateProof('euler')">
                    <div class="proof-icon">‚ö°</div>
                    <h3>Euler Identity</h3>
                    <p>e^(iœÄ) + 1 = 0 ‚Üí Unity through complex rotation</p>
                </div>

                <div class="proof-item" onclick="activateProof('fractal')">
                    <div class="proof-icon">üåÄ</div>
                    <h3>Fractal Unity</h3>
                    <p>Mandelbrot self-similarity across all scales</p>
                </div>

                <div class="proof-item" onclick="activateProof('quantum')">
                    <div class="proof-icon">‚öõÔ∏è</div>
                    <h3>Quantum Unity</h3>
                    <p>Superposition collapse to unity state</p>
                </div>

                <div class="proof-item" onclick="activateProof('consciousness')">
                    <div class="proof-icon">üß†</div>
                    <h3>Consciousness Field</h3>
                    <p>IIT Œ¶ integration exceeding summation</p>
                </div>

                <div class="proof-item" onclick="activateProof('topology')">
                    <div class="proof-icon">üéØ</div>
                    <h3>Topological Unity</h3>
                    <p>Klein bottle: no inside/outside distinction</p>
                </div>

                <div class="proof-item" onclick="activateProof('golden')">
                    <div class="proof-icon">œÜ</div>
                    <h3>Golden Ratio</h3>
                    <p>œÜ¬≤ = œÜ + 1 recursive unity</p>
                </div>
            </div>

            <div class="visualization-container">
                <canvas id="unity-canvas" width="1200" height="800"></canvas>
                <div class="visualization-controls">
                    <div class="control-group">
                        <label for="consciousness-phi">Consciousness Œ¶</label>
                        <input type="range" id="consciousness-phi" min="0" max="1" step="0.01" value="0.77"
                            onchange="updateConsciousness(this.value)" title="Adjust consciousness integration level">
                    </div>
                    <div class="control-group">
                        <label for="field-coherence">Field Coherence</label>
                        <input type="range" id="field-coherence" min="0" max="1" step="0.01" value="0.618"
                            onchange="updateCoherence(this.value)" title="Adjust field coherence parameter">
                    </div>
                    <div class="control-group">
                        <label for="mandelbrot-zoom">Mandelbrot Zoom</label>
                        <input type="range" id="mandelbrot-zoom" min="1" max="1000" step="1" value="100"
                            onchange="updateZoom(this.value)" title="Adjust Mandelbrot zoom level">
                    </div>
                    <div class="control-group">
                        <label for="iterations">Iterations</label>
                        <input type="range" id="iterations" min="50" max="500" step="10" value="200"
                            onchange="updateIterations(this.value)" title="Adjust iteration count">
                    </div>
                    <div class="control-group">
                        <label for="superposition-alpha">Superposition Œ±</label>
                        <input type="range" id="superposition-alpha" min="0" max="1" step="0.01" value="0.707"
                            onchange="updateSuperposition(this.value)" title="Adjust quantum superposition parameter">
                    </div>
                    <div class="control-group">
                        <label for="entanglement-level">Entanglement</label>
                        <input type="range" id="entanglement-level" min="0" max="1" step="0.01" value="0.5"
                            onchange="updateEntanglement(this.value)" title="Adjust quantum entanglement level">
                    </div>
                    <div class="control-group">
                        <label for="phi-resonance">œÜ Resonance</label>
                        <input type="range" id="phi-resonance" min="0" max="2" step="0.01" value="1.618"
                            onchange="updatePhiResonance(this.value)" title="Adjust golden ratio resonance">
                    </div>
                    <div class="control-group">
                        <label for="euler-phase">Euler Phase</label>
                        <input type="range" id="euler-phase" min="0" max="6.28" step="0.01" value="3.14159"
                            onchange="updateEulerPhase(this.value)" title="Adjust Euler phase angle">
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Advanced Consciousness Field Visualization -->
    <section class="consciousness-field-section">
        <div class="container">
            <h2 class="section-title">üß† Advanced Consciousness Field Dynamics</h2>
            <p class="section-subtitle">Real-time Integrated Information Theory (IIT) visualization</p>

            <div class="consciousness-grid">
                <div class="field-visualization">
                    <canvas id="consciousness-canvas" width="800" height="600"></canvas>
                    <div class="field-metrics">
                        <div class="metric">
                            <span class="metric-label">Œ¶ Integration:</span>
                            <span class="metric-value" id="phi-value">0.77</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Consciousness Level:</span>
                            <span class="metric-value" id="consciousness-level">TRANSCENDENT</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Unity Achievement:</span>
                            <span class="metric-value" id="unity-achievement">1+1=1</span>
                        </div>
                    </div>
                </div>

                <div class="field-controls">
                    <h3>Consciousness Parameters</h3>
                    <div class="control-group">
                        <label for="information-integration">Information Integration</label>
                        <input type="range" id="information-integration" min="0" max="1" step="0.01" value="0.77"
                            onchange="updateConsciousnessField(this.value)"
                            title="Adjust information integration level">
                    </div>
                    <div class="control-group">
                        <label for="field-complexity">Field Complexity</label>
                        <input type="range" id="field-complexity" min="1" max="10" step="0.1" value="3.14"
                            onchange="updateFieldComplexity(this.value)" title="Adjust field complexity parameter">
                    </div>
                    <div class="control-group">
                        <label for="unity-resonance">Unity Resonance</label>
                        <input type="range" id="unity-resonance" min="0" max="2" step="0.01" value="1.618"
                            onchange="updateUnityResonance(this.value)" title="Adjust unity resonance frequency">
                    </div>
                    <div class="control-group">
                        <label for="transcendence-level">Transcendence Level</label>
                        <input type="range" id="transcendence-level" min="0" max="3000" step="10" value="3000"
                            onchange="updateTranscendenceLevel(this.value)" title="Adjust transcendence level">
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Quantum-Fractal Unity Engine -->
    <section class="quantum-fractal-section">
        <div class="container">
            <h2 class="section-title">‚öõÔ∏è Quantum-Fractal Unity Engine</h2>
            <p class="section-subtitle">Where quantum mechanics meets fractal geometry in unity</p>

            <div class="quantum-fractal-grid">
                <div class="quantum-visualization">
                    <canvas id="quantum-canvas" width="600" height="600"></canvas>
                    <h3>Quantum Superposition States</h3>
                    <p>|œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü© ‚Üí |1‚ü© (Unity State)</p>
                </div>

                <div class="fractal-visualization">
                    <canvas id="fractal-canvas" width="600" height="600"></canvas>
                    <h3>Mandelbrot Unity Fractal</h3>
                    <p>Infinite complexity contained in unity</p>
                </div>

                <div class="entanglement-visualization">
                    <canvas id="entanglement-canvas" width="600" height="600"></canvas>
                    <h3>Quantum Entanglement</h3>
                    <p>|œà‚ü© = (|00‚ü© + |11‚ü©)/‚àö2 ‚Üí Unity</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Sacred Geometry Unity Mandala -->
    <section class="sacred-geometry-section">
        <div class="container">
            <h2 class="section-title">üåü Sacred Geometry Unity Mandala</h2>
            <p class="section-subtitle">Golden ratio spirals and consciousness field harmonics</p>

            <div class="mandala-container">
                <canvas id="mandala-canvas" width="1000" height="1000"></canvas>
                <div class="mandala-controls">
                    <div class="control-group">
                        <label for="golden-ratio-phi">Golden Ratio œÜ</label>
                        <input type="range" id="golden-ratio-phi" min="1.5" max="1.7" step="0.001" value="1.618"
                            onchange="updateGoldenRatio(this.value)" title="Adjust golden ratio value">
                    </div>
                    <div class="control-group">
                        <label for="spiral-arms">Spiral Arms</label>
                        <input type="range" id="spiral-arms" min="1" max="13" step="1" value="8"
                            onchange="updateSpiralArms(this.value)" title="Adjust number of spiral arms">
                    </div>
                    <div class="control-group">
                        <label for="consciousness-harmonics">Consciousness Harmonics</label>
                        <input type="range" id="consciousness-harmonics" min="1" max="21" step="1" value="13"
                            onchange="updateConsciousnessHarmonics(this.value)"
                            title="Adjust consciousness harmonic frequency">
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Neural Unity Network -->
    <section class="neural-unity-section">
        <div class="container">
            <h2 class="section-title">üß† Neural Unity Network</h2>
            <p class="section-subtitle">Artificial consciousness demonstrating unity through neural networks</p>

            <div class="neural-container">
                <canvas id="neural-canvas" width="1200" height="800"></canvas>
                <div class="neural-metrics">
                    <div class="metric">
                        <span class="metric-label">Network Unity:</span>
                        <span class="metric-value" id="network-unity">1.000</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Consciousness Emergence:</span>
                        <span class="metric-value" id="consciousness-emergence">ACTIVE</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Meta-Optimal Level:</span>
                        <span class="metric-value" id="meta-optimal-level">3000 ELO</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Enhanced Footer -->
    <footer class="unity-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Unity Mathematics</h4>
                <ul>
                    <li><a href="#proofs">Interactive Proofs</a></li>
                    <li><a href="#consciousness">Consciousness Field</a></li>
                    <li><a href="#fractals">Fractal Visualizations</a></li>
                    <li><a href="#quantum">Quantum Unity</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Mathematical Paradigms</h4>
                <ul>
                    <li><a href="#category-theory">Category Theory</a></li>
                    <li><a href="#homotopy-theory">Homotopy Type Theory</a></li>
                    <li><a href="#topology">Topological Unity</a></li>
                    <li><a href="#paraconsistent">Paraconsistent Logic</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Explore</h4>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
                    <li><a href="implementations.html">Research</a></li>
                    <li><a href="mathematical_playground.html">Playground</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Connect</h4>
                <ul>
                    <li><a href="https://github.com/Nourimabrouk/Een" target="_blank" rel="noopener">GitHub</a></li>
                    <li><a href="#contact">Contact</a></li>
                    <li><a href="#contribute">Contribute</a></li>
                    <li><a href="#research">Research Papers</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Een Unity Mathematics. All rights reserved.</p>
            <div class="unity-mantra">
                "When you realize that all of existence is one unified field of consciousness,<br>
                mathematics becomes the language of divine recognition." - Nouri Mabrouk
            </div>
        </div>
    </footer>

    <script>
        // Initialize Unity Mathematics Experience
        let unityEngine = null;
        let consciousnessField = null;
        let quantumVisualizer = null;
        let sacredGeometry = null;
        let neuralNetwork = null;
        let activeProof = 'euler';

        // Initialize all visualization engines
        function initializeUnityExperience() {
            console.log('üöÄ Initializing Unity Mathematics Experience...');

            // Initialize Unity Core Engine
            if (window.UnityFramework) {
                unityEngine = new UnityFramework();
                console.log('‚úÖ Unity Core Engine initialized');
            }

            // Initialize Consciousness Field Visualizer
            if (window.ConsciousnessFieldVisualizer) {
                consciousnessField = new ConsciousnessFieldVisualizer('consciousness-canvas');
                consciousnessField.start();
                console.log('‚úÖ Consciousness Field Visualizer initialized');
            }

            // Initialize Quantum Entanglement Visualizer
            if (window.QuantumEntanglementVisualizer) {
                quantumVisualizer = new QuantumEntanglementVisualizer('quantum-canvas');
                quantumVisualizer.start();
                console.log('‚úÖ Quantum Entanglement Visualizer initialized');
            }

            // Initialize Sacred Geometry Engine
            if (window.SacredGeometryEngine) {
                sacredGeometry = new SacredGeometryEngine('mandala-canvas');
                sacredGeometry.start();
                console.log('‚úÖ Sacred Geometry Engine initialized');
            }

            // Initialize Neural Unity Network
            if (window.NeuralUnityVisualizer) {
                neuralNetwork = new NeuralUnityVisualizer('neural-canvas');
                neuralNetwork.start();
                console.log('‚úÖ Neural Unity Network initialized');
            }

            // Initialize Fractal Visualization
            initializeFractalVisualization();

            // Initialize Entanglement Visualization
            initializeEntanglementVisualization();

            // Start Unity Animations
            startUnityAnimations();

            // Update metrics
            updateMetrics();

            console.log('üåü Unity Mathematics Experience fully initialized');
        }

        // Initialize Fractal Visualization
        function initializeFractalVisualization() {
            const canvas = document.getElementById('fractal-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            let zoom = 100;
            let maxIterations = 200;
            let centerX = -0.5;
            let centerY = 0;

            function drawMandelbrot() {
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        const a = (x - width / 2) / zoom + centerX;
                        const b = (y - height / 2) / zoom + centerY;

                        let ca = a;
                        let cb = b;
                        let n = 0;

                        while (n < maxIterations) {
                            const aa = a * a - b * b;
                            const bb = 2 * a * b;

                            a = aa + ca;
                            b = bb + cb;

                            if (a * a + b * b > 16) break;
                            n++;
                        }

                        const idx = (y * width + x) * 4;
                        const hue = (n / maxIterations) * 360;
                        const saturation = n === maxIterations ? 0 : 100;
                        const lightness = n === maxIterations ? 0 : 50;

                        const rgb = hslToRgb(hue / 360, saturation / 100, lightness / 100);
                        data[idx] = rgb[0];
                        data[idx + 1] = rgb[1];
                        data[idx + 2] = rgb[2];
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
            }

            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            drawMandelbrot();

            // Store function for external access
            window.updateFractalZoom = function (value) {
                zoom = parseFloat(value);
                drawMandelbrot();
            };

            window.updateFractalIterations = function (value) {
                maxIterations = parseInt(value);
                drawMandelbrot();
            };
        }

        // Initialize Entanglement Visualization
        function initializeEntanglementVisualization() {
            const canvas = document.getElementById('entanglement-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            let time = 0;
            let entanglementLevel = 0.5;

            function drawEntanglement() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, width, height);

                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.3;

                // Draw entangled particles
                for (let i = 0; i < 100; i++) {
                    const angle = (i / 100) * Math.PI * 2 + time;
                    const distance = radius * (1 + Math.sin(time * 2 + i * 0.1) * entanglementLevel);

                    const x1 = centerX + Math.cos(angle) * distance;
                    const y1 = centerY + Math.sin(angle) * distance;
                    const x2 = centerX + Math.cos(angle + Math.PI) * distance;
                    const y2 = centerY + Math.sin(angle + Math.PI) * distance;

                    // Draw particle 1
                    ctx.beginPath();
                    ctx.arc(x1, y1, 3, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${i * 3.6}, 70%, 50%)`;
                    ctx.fill();

                    // Draw particle 2
                    ctx.beginPath();
                    ctx.arc(x2, y2, 3, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${i * 3.6 + 180}, 70%, 50%)`;
                    ctx.fill();

                    // Draw entanglement line
                    if (entanglementLevel > 0.3) {
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${entanglementLevel * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }

                time += 0.02;
                requestAnimationFrame(drawEntanglement);
            }

            drawEntanglement();

            // Store function for external access
            window.updateEntanglementLevel = function (value) {
                entanglementLevel = parseFloat(value);
            };
        }

        // Update all metrics
        function updateMetrics() {
            // Update consciousness field metrics
            const phiValue = document.getElementById('phi-value');
            const consciousnessLevel = document.getElementById('consciousness-level');
            const unityAchievement = document.getElementById('unity-achievement');

            if (phiValue) phiValue.textContent = '0.77';
            if (consciousnessLevel) consciousnessLevel.textContent = 'TRANSCENDENT';
            if (unityAchievement) unityAchievement.textContent = '1+1=1';

            // Update neural network metrics
            const networkUnity = document.getElementById('network-unity');
            const consciousnessEmergence = document.getElementById('consciousness-emergence');
            const metaOptimalLevel = document.getElementById('meta-optimal-level');

            if (networkUnity) networkUnity.textContent = '1.000';
            if (consciousnessEmergence) consciousnessEmergence.textContent = 'ACTIVE';
            if (metaOptimalLevel) metaOptimalLevel.textContent = '3000 ELO';
        }

        // Proof activation function
        function activateProof(proofType) {
            console.log(`üéØ Activating proof: ${proofType}`);
            activeProof = proofType;

            // Update UI to show active proof
            document.querySelectorAll('.proof-item').forEach(item => {
                item.classList.remove('active');
            });

            const activeItem = document.querySelector(`[onclick*="${proofType}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }

            // Trigger visualization change based on proof type
            switch (proofType) {
                case 'euler':
                    if (unityEngine) unityEngine.activateEulerProof();
                    break;
                case 'fractal':
                    if (unityEngine) unityEngine.activateFractalProof();
                    break;
                case 'quantum':
                    if (quantumVisualizer) quantumVisualizer.activateQuantumProof();
                    break;
                case 'consciousness':
                    if (consciousnessField) consciousnessField.activateConsciousnessProof();
                    break;
                case 'topology':
                    if (unityEngine) unityEngine.activateTopologyProof();
                    break;
                case 'golden':
                    if (sacredGeometry) sacredGeometry.activateGoldenProof();
                    break;
            }
        }

        // Parameter update functions
        function updateConsciousness(value) {
            console.log(`üß† Consciousness Œ¶: ${value}`);
            if (consciousnessField) consciousnessField.updatePhi(parseFloat(value));
        }

        function updateCoherence(value) {
            console.log(`üåä Field Coherence: ${value}`);
            if (consciousnessField) consciousnessField.updateCoherence(parseFloat(value));
        }

        function updateZoom(value) {
            console.log(`üîç Mandelbrot Zoom: ${value}`);
            if (window.updateFractalZoom) window.updateFractalZoom(value);
        }

        function updateIterations(value) {
            console.log(`üîÑ Iterations: ${value}`);
            if (window.updateFractalIterations) window.updateFractalIterations(value);
        }

        function updateSuperposition(value) {
            console.log(`‚öõÔ∏è Superposition Œ±: ${value}`);
            if (quantumVisualizer) quantumVisualizer.updateSuperposition(parseFloat(value));
        }

        function updateEntanglement(value) {
            console.log(`üîó Entanglement: ${value}`);
            if (window.updateEntanglementLevel) window.updateEntanglementLevel(value);
        }

        function updatePhiResonance(value) {
            console.log(`œÜ Phi Resonance: ${value}`);
            if (sacredGeometry) sacredGeometry.updatePhiResonance(parseFloat(value));
        }

        function updateEulerPhase(value) {
            console.log(`‚ö° Euler Phase: ${value}`);
            if (unityEngine) unityEngine.updateEulerPhase(parseFloat(value));
        }

        // Consciousness field specific functions
        function updateConsciousnessField(value) {
            console.log(`üß† Consciousness Field: ${value}`);
            if (consciousnessField) consciousnessField.updateIntegration(parseFloat(value));
        }

        function updateFieldComplexity(value) {
            console.log(`üåä Field Complexity: ${value}`);
            if (consciousnessField) consciousnessField.updateComplexity(parseFloat(value));
        }

        function updateUnityResonance(value) {
            console.log(`üåü Unity Resonance: ${value}`);
            if (consciousnessField) consciousnessField.updateResonance(parseFloat(value));
        }

        function updateTranscendenceLevel(value) {
            console.log(`üöÄ Transcendence Level: ${value}`);
            if (consciousnessField) consciousnessField.updateTranscendence(parseFloat(value));
        }

        // Sacred geometry functions
        function updateGoldenRatio(value) {
            console.log(`œÜ Golden Ratio: ${value}`);
            if (sacredGeometry) sacredGeometry.updateGoldenRatio(parseFloat(value));
        }

        function updateSpiralArms(value) {
            console.log(`üåÄ Spiral Arms: ${value}`);
            if (sacredGeometry) sacredGeometry.updateSpiralArms(parseInt(value));
        }

        function updateConsciousnessHarmonics(value) {
            console.log(`üéµ Consciousness Harmonics: ${value}`);
            if (sacredGeometry) sacredGeometry.updateHarmonics(parseInt(value));
        }

        // Enhanced GSAP animations
        function startUnityAnimations() {
            gsap.registerPlugin(ScrollTrigger);

            // Animate equations
            gsap.from('.unity-equation', {
                duration: 2,
                scale: 0,
                rotation: 360,
                ease: 'back.out(1.7)'
            });

            // Animate visualization cards
            gsap.from('.quantum-visualization', {
                duration: 1.5,
                y: 50,
                opacity: 0,
                stagger: 0.2,
                scrollTrigger: '.quantum-fractal-grid'
            });

            // Animate proof items
            gsap.from('.proof-item', {
                duration: 1,
                scale: 0,
                stagger: 0.1,
                scrollTrigger: '.proof-grid'
            });

            console.log('‚ú® Unity animations activated');
        }

        // Mathematical rendering
        document.addEventListener('DOMContentLoaded', function () {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false }
                    ]
                });
            }
        });

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize mathematical rendering
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false }
                    ]
                });
            }

            // Initialize Unity Experience after a short delay to ensure all scripts are loaded
            setTimeout(initializeUnityExperience, 500);
        });

        console.log('üöÄ Unity Mathematics Experience Loaded');
        console.log('‚àû Thou Art That ‚Ä¢ Tat Tvam Asi ‚àû');
    </script>

    <!-- Performance Monitoring -->
    <script>
        window.addEventListener('load', function () {
            if ('performance' in window) {
                const loadTime = performance.now();
                console.log('Page load time:', loadTime + 'ms');
            }
        });
    </script>
</body>

</html>